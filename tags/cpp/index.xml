<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cpp on #anooptube</title>
    <link>https://anooptube.in/tags/cpp/</link>
    <description>Recent content in cpp on #anooptube</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 24 Apr 2023 18:34:49 +0530</lastBuildDate><atom:link href="https://anooptube.in/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Friend Function</title>
      <link>https://anooptube.in/blog/post22/</link>
      <pubDate>Mon, 24 Apr 2023 18:34:49 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post22/</guid>
      <description>In C++, classes have three access modifiers that determine the level of access to class members. These are: public, private, and protected.
Private and protected members are accessible only within the class and its subclasses, whereas public members are accessible anywhere.
Private members are declared with the private keyword in the class definition. Private members cannot be accessed outside of the class or its friend functions. This means that only the members of the class or its friend functions can access them.</description>
    </item>
    
    <item>
      <title>Pure Virtual Functions</title>
      <link>https://anooptube.in/blog/post21/</link>
      <pubDate>Thu, 20 Apr 2023 21:51:16 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post21/</guid>
      <description>In C++, a pure virtual function is a virtual function that is declared in a base class but does not provide an implementation.
Syntax: virtual return_type functionName(parameters) = 0; Where = 0 at the end of the declaration indicates that the function is pure virtual.
A class that contains one or more pure virtual functions is called an abstract class, and it cannot be instantiated (can not create an object for this class).</description>
    </item>
    
    <item>
      <title>Virtual Functions</title>
      <link>https://anooptube.in/blog/post20/</link>
      <pubDate>Thu, 20 Apr 2023 18:58:41 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post20/</guid>
      <description>In C++, a virtual function is a member function of a class that can be overridden in a derived class. When a virtual function is called on a derived class object, the function of the derived class is called instead of the function of the base class. This is known as dynamic binding or runtime polymorphism.
Syntax: virtual return_type functionName() { //body of the function return statement; } Suppose we have a base class named Shape and three derived classes named Circle and Rectangle and Triangle.</description>
    </item>
    
    <item>
      <title>Arrow Operator</title>
      <link>https://anooptube.in/blog/post17/</link>
      <pubDate>Sat, 01 Apr 2023 19:50:04 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post17/</guid>
      <description>We can create a pointer variable for Complex data types such as struct and class. Also we can create a pointer for class and struct in stack and heap As similar as primitive data types.
Syntax className *pointerName; pointerName = &amp;amp;classObjectName; Example struct Student { int mark; std::string name; }; int main(int argc, char const *argv[]) { Student s; s.mark = 10; s.name = &amp;#34;ANOOP&amp;#34;; Student *sPtr = &amp;amp;s; } Accessing data members using pointer: We can access data members of a struct/class pointer variable by using * operator with .</description>
    </item>
    
    <item>
      <title>New and Delete Operators</title>
      <link>https://anooptube.in/blog/post16/</link>
      <pubDate>Wed, 29 Mar 2023 19:23:16 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post16/</guid>
      <description>C++ allows us to create variables at runtime. The variable can be created in Stack memory or Heap memory.
Memory Layout in C++ Stack Memory Functions are allocated stack memory every time they are called by the machine. Whenever a new local variable is declared, more stack memory is allocated to store the variable in that function.
Stacks grow downward when such allocations are made. All local variables of this function become invalid after the function returns, since the stack memory of this function is deallocated.</description>
    </item>
    
    <item>
      <title>Basics Of Pointers</title>
      <link>https://anooptube.in/blog/post15/</link>
      <pubDate>Sat, 18 Mar 2023 19:41:47 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post15/</guid>
      <description>A pointer is a special type of variable that can hold the memory address of an another variable.
Overview of C++ Pointers 1. Accessing address of a variable We can access the memory address of a variable by &amp;amp; symbol
int x = 10; &amp;amp;x // gives the memory address Example #include &amp;lt;iostream&amp;gt; int main() { int mark = 300; int age = 24; int salary = 17000; std::cout &amp;lt;&amp;lt; &amp;#34;Address of mark: &amp;#34;&amp;lt;&amp;lt; &amp;amp;mark &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;Address of age: &amp;#34; &amp;lt;&amp;lt; &amp;amp;age &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;Address of salary: &amp;#34; &amp;lt;&amp;lt; &amp;amp;salary &amp;lt;&amp;lt; std::endl; } 2.</description>
    </item>
    
    <item>
      <title>Function Overriding</title>
      <link>https://anooptube.in/blog/post14/</link>
      <pubDate>Wed, 15 Mar 2023 23:08:47 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post14/</guid>
      <description>Our knowledge of inheritance begins with the fact that we can create derived classes from a base class, which is one of the core features of OOP. A derived class inherits the features of a base class.
Assume that the same function is defined in both the derived class and the based class. When we call this function using the object of the derived class, the derived class&amp;rsquo;s function is executed.</description>
    </item>
    
    <item>
      <title>Inheritance</title>
      <link>https://anooptube.in/blog/post13/</link>
      <pubDate>Thu, 05 Jan 2023 15:50:10 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post13/</guid>
      <description>C++ supports inheritance as a key feature of Object Oriented Programming (OOP). It is a method for creating new classes (derived classes) from existing classes (base classes).
Base class and Derived class A derived class inherits the features of a base class as well as its own features.
Each shape has two properties, for example area and perimeter. And child classes should be able to access these properties, so we have given them the protected access specifier.</description>
    </item>
    
    <item>
      <title>C v/s C&#43;&#43;</title>
      <link>https://anooptube.in/blog/post12/</link>
      <pubDate>Mon, 26 Dec 2022 19:07:45 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post12/</guid>
      <description>1. File Extension: C - Files are saved with .c extension. C++ - Files are saved with .cpp extension. 2. Area of usage: C - Embedded devices And system-level code. C++ - Gaming,networking and server-side applications. 3. Compatibility: C - The C compiler isnâ€™t able to execute the C++ code. C++ - C++ is a superset of C so C++ is able to run most C code. 4. OOP - Compatibility: C - It does not Support Object-Oriented -Programming (OOP) C++ - It Support Object-Oriented -Programming (OOP) for more visit Class and Objects in C++</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Input and Output Functions</title>
      <link>https://anooptube.in/blog/post11/</link>
      <pubDate>Wed, 14 Dec 2022 19:36:41 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post11/</guid>
      <description>1. Output Functions. The output functions display the results to the user.
Syntax: #include &amp;lt;iostream&amp;gt; std::cout &amp;lt;&amp;lt; &amp;#34;message&amp;#34; ; std::cout &amp;lt;&amp;lt; variables; Example: #include &amp;lt;iostream&amp;gt; int main() { // print strings std::cout &amp;lt;&amp;lt; &amp;#34;Welcome to #anooptube\n&amp;#34;; int age = 18; double salary = 12000.50; // print the variables std::cout &amp;lt;&amp;lt; age &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; salary &amp;lt;&amp;lt; std::endl; // print two or more variables std::cout &amp;lt;&amp;lt; &amp;#34;Your age is: &amp;#34; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &amp;#34; and salary is: &amp;#34; &amp;lt;&amp;lt; salary &amp;lt;&amp;lt; std::endl; return 0; } To print a new line, use std::endl or \n</description>
    </item>
    
    <item>
      <title>Abstraction &amp; Encapsulation</title>
      <link>https://anooptube.in/blog/post10/</link>
      <pubDate>Sat, 03 Dec 2022 14:52:58 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post10/</guid>
      <description>1. Abstraction Data Abstraction involves presenting only the essential details to the outside world, i.e., representing only the essential details inside the program, and hiding the other details.
How to achieve Abstraction 1. By Header files. Example:
Create a header file person.h // person.h #ifndef ANOOP_TUBE_PERSON_H #define ANOOP_TUBE_PERSON_H #include&amp;lt;iostream&amp;gt; class Person { public: Person(std::string name_); std::string getName(); void setName(std::string name_); private: std::string name; }; #endif create a file person.cpp include person.</description>
    </item>
    
    <item>
      <title>Create Header Files</title>
      <link>https://anooptube.in/blog/post9/</link>
      <pubDate>Sat, 03 Dec 2022 12:49:20 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post9/</guid>
      <description>A header file contains the declarations and definitions of functions and macros.
Types: System header files. Example : iostream , vector, string ..etc.
User defined header files. How to use header files We use a special pre-processor directive called #include to use/include header files.
Syntax for System header files: #include &amp;lt;header_file_name&amp;gt; Example: #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; Syntax for User defined header files: #include &amp;#34;path/to/header_file_name.h&amp;#34; Example: #include &amp;#34;anooptube.h&amp;#34; #include &amp;#34;my_header_file.h Make your own header file and use it.</description>
    </item>
    
    <item>
      <title>How to create a namespace in C&#43;&#43;</title>
      <link>https://anooptube.in/blog/post8/</link>
      <pubDate>Wed, 30 Nov 2022 19:13:59 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post8/</guid>
      <description>In C++ programming, a namespace is a collection of names or identifiers related to one another.
Syntax: namespace namespace_name { // code here } Example: namespace anooptube_namespace { int getName() { std::cout &amp;lt;&amp;lt; &amp;#34;#anooptube&amp;#34; &amp;lt;&amp;lt; std::endl; } } How to create a arithmetic namespace Step-1: Create a header file named arithmetic.h Add header guards.
// arithmetic.h #ifndef ANOOPTUBE_ARITHMETIC_H #define ANOOPTUBE_ARITHMETIC_H #endif Add namespace declaration. // arithmetic.h #ifndef ANOOPTUBE_ARITHMETIC_H #define ANOOPTUBE_ARITHMETIC_H namespace arithmetic { } #endif Add required functions.</description>
    </item>
    
    <item>
      <title>String snd Boolean</title>
      <link>https://anooptube.in/blog/post6/</link>
      <pubDate>Fri, 18 Nov 2022 22:51:46 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post6/</guid>
      <description>1. Boolean bool is a data type which can hold the values true or false. Syntax: bool varName = value; Example: #include &amp;lt;iostream&amp;gt; int main() { bool varName1 = true; bool varName2 = false; std::cout &amp;lt;&amp;lt; varName1 &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; varName2 &amp;lt;&amp;lt; std::endl; int age; std::cout &amp;lt;&amp;lt; &amp;#34;Enter your age:&amp;#34;; std::cin &amp;gt;&amp;gt; age; bool isGreater18 = age &amp;gt;= 18; std::cout &amp;lt;&amp;lt; &amp;#34;isGreater18: &amp;#34; &amp;lt;&amp;lt; isGreater18; } Related videos: link 2.</description>
    </item>
    
    <item>
      <title>Class and Objects in C&#43;&#43;</title>
      <link>https://anooptube.in/blog/post5/</link>
      <pubDate>Fri, 18 Nov 2022 22:45:30 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post5/</guid>
      <description>1. Class A class is a template(prototype) for the object.
class is collection of data and its functions/methods
Related videos link Syntax: class ClassName { // body of class access_specifier: // data // methods / functions }; Example: class Rectangle { public: // data members double length; double width; // functions / methods double getArea() { return length * width; } }; 2. Objects Object is an instance of class. The allocation of memory only occurs when an object is created.</description>
    </item>
    
    <item>
      <title>Constructor &amp; Destructor</title>
      <link>https://anooptube.in/blog/post4/</link>
      <pubDate>Fri, 18 Nov 2022 22:45:26 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post4/</guid>
      <description>1. Constructor A special type of member function. Constructor called automatically when an object is created. Constructor Name is same as Class Name. Constructor has no return type. Related videos link Constructor Types Default Constructor. Parameterized Constructor. 2. Destructor A special type of member function. Destructor called automatically when an object is deleted. Destructor Name is same as Class Name. Destructor has no return type. Example Program class Rectangle { public: // Default Constructor Rectangle() { std::cout &amp;lt;&amp;lt; &amp;#34;Default Constructor called&amp;#34; &amp;lt;&amp;lt; std::endl; length = 0; width = 0; } // Parameterized Constructor Rectangle(int len, int wid) { std::cout &amp;lt;&amp;lt; &amp;#34;Parameterized Constructor called&amp;#34; &amp;lt;&amp;lt; std::endl; length = len; width = wid; } // Destructor ~Rectangle() { std::cout &amp;lt;&amp;lt; &amp;#34;Destructor called &amp;#34; &amp;lt;&amp;lt; std::endl; } // functions double getArea() { return length * width; } // data members double length; double width; }; int main() { // Program start here Rectangle r1(20,20); // accessing the members // dot operator &amp;#34;.</description>
    </item>
    
    <item>
      <title>Operator Overloading</title>
      <link>https://anooptube.in/blog/post3/</link>
      <pubDate>Fri, 18 Nov 2022 22:45:15 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post3/</guid>
      <description>A special function operator can be used to overload operators.
Related videos Part-1 - link Part-2 - link Syntax return_type operator operator_symbol(arguments) { //body return value } where operator_symbol can be
%, +, -, *, / , ++, --, !, ==, !=, &amp;gt;=, &amp;lt;= , &amp;amp;&amp;amp; , || , =, +=,*=, /=,-=, %= , [ ], &amp;amp;, |, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, ^, ~ 4 operators that cannot be overloaded in C++ 1.</description>
    </item>
    
    <item>
      <title>Overloading in C&#43;&#43;</title>
      <link>https://anooptube.in/blog/post2/</link>
      <pubDate>Fri, 18 Nov 2022 20:04:52 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post2/</guid>
      <description>Types Of Overloading Constructor Overloading
Function Overloading
Related video link 1. Constructor Overloading All constructors have same name but
different number of arguments
#include&amp;lt;iostream&amp;gt; class Rectangle { public: // Constructor Rectangle() { length = 0; width = 0; } Rectangle(double len, double wid) { length = len; width = wid; } Rectangle(double side) { length = side; width = side; } void print() { std::cout &amp;lt;&amp;lt; &amp;#34;length: &amp;#34;&amp;lt;&amp;lt; length &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;width: &amp;#34;&amp;lt;&amp;lt; width &amp;lt;&amp;lt; std::endl; } double length; double width; }; int main(int argc, char const *argv[]) { Rectangle r1; r1.</description>
    </item>
    
    <item>
      <title>Access Modifiers/Specifiers</title>
      <link>https://anooptube.in/blog/post1/</link>
      <pubDate>Thu, 17 Nov 2022 23:12:05 +0530</pubDate>
      
      <guid>https://anooptube.in/blog/post1/</guid>
      <description>Types Of Access Specifiers Public Private Protected Related videos link 1. Public public members can be access from any part of the program.
class Rectangle { public: Rectangle() { length = 0; width = 0; } Rectangle(double l, double w) { length = l; width = w; } double getArea() { return length * width; } double length, width; }; int main(int argc, char const *argv[]) { Rectangle r1(10,20); std::cout &amp;lt;&amp;lt; &amp;#34;length :&amp;#34; &amp;lt;&amp;lt; r1.</description>
    </item>
    
  </channel>
</rss>
